/**
 * auto generated by graphql-codegen
 * DO NOT EDIT THIS FILE BY HAND
 */

export type Maybe<T> = T | null

export type DateTime = any

// ====================================================
// Scalars
// ====================================================

// ====================================================
// Types
// ====================================================

export interface Query {
  organizers: Organizer[]

  upcomingEvents: Event[]

  upcomingTalks: Talk[]
}

export interface Organizer {
  description: string

  name: string

  twitter: TwitterAccount
}

export interface TwitterAccount {
  name: string

  profileImageUrl: string
}

export interface Event {
  date: DateTime

  goingCount: number

  url: string

  venue: EventVenue
}

export interface EventVenue {
  city: string

  country: string

  lat: number

  lon: number

  name: string

  street: string
}

export interface Talk {
  date: DateTime

  description: string

  isLightningTalk: boolean

  labels: string[]

  speaker: Speaker

  title: string
}

export interface Speaker {
  avatarUrl: string

  name: string

  occupation: string

  socialName?: Maybe<string>

  socialUrl?: Maybe<string>
}

// ====================================================
// Arguments
// ====================================================

import {
  GraphQLResolveInfo,
  GraphQLScalarType,
  GraphQLScalarTypeConfig,
} from 'graphql'

import { ContextType } from '../utils/createContext'

export type Resolver<Result, Parent = {}, Context = {}, Args = {}> = (
  parent: Parent,
  args: Args,
  context: Context,
  info: GraphQLResolveInfo
) => Promise<Result> | Result

export interface ISubscriptionResolverObject<Result, Parent, Context, Args> {
  subscribe<R = Result, P = Parent>(
    parent: P,
    args: Args,
    context: Context,
    info: GraphQLResolveInfo
  ): AsyncIterator<R | Result> | Promise<AsyncIterator<R | Result>>
  resolve?<R = Result, P = Parent>(
    parent: P,
    args: Args,
    context: Context,
    info: GraphQLResolveInfo
  ): R | Result | Promise<R | Result>
}

export type SubscriptionResolver<
  Result,
  Parent = {},
  Context = {},
  Args = {}
> =
  | ((
      ...args: any[]
    ) => ISubscriptionResolverObject<Result, Parent, Context, Args>)
  | ISubscriptionResolverObject<Result, Parent, Context, Args>

export type TypeResolveFn<Types, Parent = {}, Context = {}> = (
  parent: Parent,
  context: Context,
  info: GraphQLResolveInfo
) => Maybe<Types>

export type NextResolverFn<T> = () => Promise<T>

export type DirectiveResolverFn<TResult, TArgs = {}, TContext = {}> = (
  next: NextResolverFn<TResult>,
  source: any,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>

export namespace QueryResolvers {
  export interface Resolvers<Context = ContextType, TypeParent = {}> {
    organizers?: OrganizersResolver<Organizer[], TypeParent, Context>

    upcomingEvents?: UpcomingEventsResolver<Event[], TypeParent, Context>

    upcomingTalks?: UpcomingTalksResolver<Talk[], TypeParent, Context>
  }

  export type OrganizersResolver<
    R = Organizer[],
    Parent = {},
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type UpcomingEventsResolver<
    R = Event[],
    Parent = {},
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type UpcomingTalksResolver<
    R = Talk[],
    Parent = {},
    Context = ContextType
  > = Resolver<R, Parent, Context>
}

export namespace OrganizerResolvers {
  export interface Resolvers<Context = ContextType, TypeParent = Organizer> {
    description?: DescriptionResolver<string, TypeParent, Context>

    name?: NameResolver<string, TypeParent, Context>

    twitter?: TwitterResolver<TwitterAccount, TypeParent, Context>
  }

  export type DescriptionResolver<
    R = string,
    Parent = Organizer,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type NameResolver<
    R = string,
    Parent = Organizer,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type TwitterResolver<
    R = TwitterAccount,
    Parent = Organizer,
    Context = ContextType
  > = Resolver<R, Parent, Context>
}

export namespace TwitterAccountResolvers {
  export interface Resolvers<
    Context = ContextType,
    TypeParent = TwitterAccount
  > {
    name?: NameResolver<string, TypeParent, Context>

    profileImageUrl?: ProfileImageUrlResolver<string, TypeParent, Context>
  }

  export type NameResolver<
    R = string,
    Parent = TwitterAccount,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type ProfileImageUrlResolver<
    R = string,
    Parent = TwitterAccount,
    Context = ContextType
  > = Resolver<R, Parent, Context>
}

export namespace EventResolvers {
  export interface Resolvers<Context = ContextType, TypeParent = Event> {
    date?: DateResolver<DateTime, TypeParent, Context>

    goingCount?: GoingCountResolver<number, TypeParent, Context>

    url?: UrlResolver<string, TypeParent, Context>

    venue?: VenueResolver<EventVenue, TypeParent, Context>
  }

  export type DateResolver<
    R = DateTime,
    Parent = Event,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type GoingCountResolver<
    R = number,
    Parent = Event,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type UrlResolver<
    R = string,
    Parent = Event,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type VenueResolver<
    R = EventVenue,
    Parent = Event,
    Context = ContextType
  > = Resolver<R, Parent, Context>
}

export namespace EventVenueResolvers {
  export interface Resolvers<Context = ContextType, TypeParent = EventVenue> {
    city?: CityResolver<string, TypeParent, Context>

    country?: CountryResolver<string, TypeParent, Context>

    lat?: LatResolver<number, TypeParent, Context>

    lon?: LonResolver<number, TypeParent, Context>

    name?: NameResolver<string, TypeParent, Context>

    street?: StreetResolver<string, TypeParent, Context>
  }

  export type CityResolver<
    R = string,
    Parent = EventVenue,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type CountryResolver<
    R = string,
    Parent = EventVenue,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type LatResolver<
    R = number,
    Parent = EventVenue,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type LonResolver<
    R = number,
    Parent = EventVenue,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type NameResolver<
    R = string,
    Parent = EventVenue,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type StreetResolver<
    R = string,
    Parent = EventVenue,
    Context = ContextType
  > = Resolver<R, Parent, Context>
}

export namespace TalkResolvers {
  export interface Resolvers<Context = ContextType, TypeParent = Talk> {
    date?: DateResolver<DateTime, TypeParent, Context>

    description?: DescriptionResolver<string, TypeParent, Context>

    isLightningTalk?: IsLightningTalkResolver<boolean, TypeParent, Context>

    labels?: LabelsResolver<string[], TypeParent, Context>

    speaker?: SpeakerResolver<Speaker, TypeParent, Context>

    title?: TitleResolver<string, TypeParent, Context>
  }

  export type DateResolver<
    R = DateTime,
    Parent = Talk,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type DescriptionResolver<
    R = string,
    Parent = Talk,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type IsLightningTalkResolver<
    R = boolean,
    Parent = Talk,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type LabelsResolver<
    R = string[],
    Parent = Talk,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type SpeakerResolver<
    R = Speaker,
    Parent = Talk,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type TitleResolver<
    R = string,
    Parent = Talk,
    Context = ContextType
  > = Resolver<R, Parent, Context>
}

export namespace SpeakerResolvers {
  export interface Resolvers<Context = ContextType, TypeParent = Speaker> {
    avatarUrl?: AvatarUrlResolver<string, TypeParent, Context>

    name?: NameResolver<string, TypeParent, Context>

    occupation?: OccupationResolver<string, TypeParent, Context>

    socialName?: SocialNameResolver<Maybe<string>, TypeParent, Context>

    socialUrl?: SocialUrlResolver<Maybe<string>, TypeParent, Context>
  }

  export type AvatarUrlResolver<
    R = string,
    Parent = Speaker,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type NameResolver<
    R = string,
    Parent = Speaker,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type OccupationResolver<
    R = string,
    Parent = Speaker,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type SocialNameResolver<
    R = Maybe<string>,
    Parent = Speaker,
    Context = ContextType
  > = Resolver<R, Parent, Context>
  export type SocialUrlResolver<
    R = Maybe<string>,
    Parent = Speaker,
    Context = ContextType
  > = Resolver<R, Parent, Context>
}

/** Directs the executor to skip this field or fragment when the `if` argument is true. */
export type SkipDirectiveResolver<Result> = DirectiveResolverFn<
  Result,
  SkipDirectiveArgs,
  ContextType
>
export interface SkipDirectiveArgs {
  /** Skipped when true. */
  if: boolean
}

/** Directs the executor to include this field or fragment only when the `if` argument is true. */
export type IncludeDirectiveResolver<Result> = DirectiveResolverFn<
  Result,
  IncludeDirectiveArgs,
  ContextType
>
export interface IncludeDirectiveArgs {
  /** Included when true. */
  if: boolean
}

/** Marks an element of a GraphQL schema as no longer supported. */
export type DeprecatedDirectiveResolver<Result> = DirectiveResolverFn<
  Result,
  DeprecatedDirectiveArgs,
  ContextType
>
export interface DeprecatedDirectiveArgs {
  /** Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax (as specified by [CommonMark](https://commonmark.org/). */
  reason?: string
}

export interface DateTimeScalarConfig
  extends GraphQLScalarTypeConfig<DateTime, any> {
  name: 'DateTime'
}

export interface IResolvers<Context = ContextType> {
  Query?: QueryResolvers.Resolvers<Context>
  Organizer?: OrganizerResolvers.Resolvers<Context>
  TwitterAccount?: TwitterAccountResolvers.Resolvers<Context>
  Event?: EventResolvers.Resolvers<Context>
  EventVenue?: EventVenueResolvers.Resolvers<Context>
  Talk?: TalkResolvers.Resolvers<Context>
  Speaker?: SpeakerResolvers.Resolvers<Context>
  DateTime?: GraphQLScalarType
}

export interface IDirectiveResolvers<Result> {
  skip?: SkipDirectiveResolver<Result>
  include?: IncludeDirectiveResolver<Result>
  deprecated?: DeprecatedDirectiveResolver<Result>
}
