/**
 * auto generated by graphql-codegen
 * DO NOT EDIT THIS FILE BY HAND
 */

export type Maybe<T> = T | null

export type DateTime = any

// ====================================================
// Scalars
// ====================================================

// ====================================================
// Types
// ====================================================

/** The query root of Paderborn.js GraphQL interface */
export interface Query {
  /** Return a list of meetup organizers */
  organizers: Organizer[]
  /** Return a list of upcoming events */
  upcomingEvents: UpcomingEvent[]
}

/** A meetup organizer */
export interface Organizer {
  description: string

  name: string

  profileImageUrl: string

  twitterName: string
}

/** An upcoming meetup event */
export interface UpcomingEvent {
  date: DateTime

  goingCount: number

  url: string

  venue: EventVenue

  talks: Talk[]
}

/** An event venue */
export interface EventVenue {
  city: string

  country: string

  lat: number

  lon: number

  name: string

  street: string
}

/** A talk */
export interface Talk {
  date: DateTime

  description: string

  isLightningTalk: boolean

  labels: string[]

  speaker: Speaker

  title: string
}

/** A speaker */
export interface Speaker {
  avatarUrl: string

  name: string

  occupation: string

  socialName?: Maybe<string>

  socialUrl?: Maybe<string>
}

// ====================================================
// Arguments
// ====================================================

import {
  GraphQLResolveInfo,
  GraphQLScalarType,
  GraphQLScalarTypeConfig,
} from 'graphql'

import { ContextType } from '../utils/createContext'

export type Resolver<Result, Parent = {}, TContext = {}, Args = {}> = (
  parent: Parent,
  args: Args,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<Result> | Result

export interface ISubscriptionResolverObject<Result, Parent, TContext, Args> {
  subscribe<R = Result, P = Parent>(
    parent: P,
    args: Args,
    context: TContext,
    info: GraphQLResolveInfo
  ): AsyncIterator<R | Result> | Promise<AsyncIterator<R | Result>>
  resolve?<R = Result, P = Parent>(
    parent: P,
    args: Args,
    context: TContext,
    info: GraphQLResolveInfo
  ): R | Result | Promise<R | Result>
}

export type SubscriptionResolver<
  Result,
  Parent = {},
  TContext = {},
  Args = {}
> =
  | ((
      ...args: any[]
    ) => ISubscriptionResolverObject<Result, Parent, TContext, Args>)
  | ISubscriptionResolverObject<Result, Parent, TContext, Args>

export type TypeResolveFn<Types, Parent = {}, TContext = {}> = (
  parent: Parent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<Types>

export type NextResolverFn<T> = () => Promise<T>

export type DirectiveResolverFn<TResult, TArgs = {}, TContext = {}> = (
  next: NextResolverFn<TResult>,
  source: any,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>

/** The query root of Paderborn.js GraphQL interface */
export namespace QueryResolvers {
  export interface Resolvers<TContext = ContextType, TypeParent = {}> {
    /** Return a list of meetup organizers */
    organizers?: OrganizersResolver<Organizer[], TypeParent, TContext>
    /** Return a list of upcoming events */
    upcomingEvents?: UpcomingEventsResolver<
      UpcomingEvent[],
      TypeParent,
      TContext
    >
  }

  export type OrganizersResolver<
    R = Organizer[],
    Parent = {},
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type UpcomingEventsResolver<
    R = UpcomingEvent[],
    Parent = {},
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
}
/** A meetup organizer */
export namespace OrganizerResolvers {
  export interface Resolvers<TContext = ContextType, TypeParent = Organizer> {
    description?: DescriptionResolver<string, TypeParent, TContext>

    name?: NameResolver<string, TypeParent, TContext>

    profileImageUrl?: ProfileImageUrlResolver<string, TypeParent, TContext>

    twitterName?: TwitterNameResolver<string, TypeParent, TContext>
  }

  export type DescriptionResolver<
    R = string,
    Parent = Organizer,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type NameResolver<
    R = string,
    Parent = Organizer,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type ProfileImageUrlResolver<
    R = string,
    Parent = Organizer,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type TwitterNameResolver<
    R = string,
    Parent = Organizer,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
}
/** An upcoming meetup event */
export namespace UpcomingEventResolvers {
  export interface Resolvers<
    TContext = ContextType,
    TypeParent = UpcomingEvent
  > {
    date?: DateResolver<DateTime, TypeParent, TContext>

    goingCount?: GoingCountResolver<number, TypeParent, TContext>

    url?: UrlResolver<string, TypeParent, TContext>

    venue?: VenueResolver<EventVenue, TypeParent, TContext>

    talks?: TalksResolver<Talk[], TypeParent, TContext>
  }

  export type DateResolver<
    R = DateTime,
    Parent = UpcomingEvent,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type GoingCountResolver<
    R = number,
    Parent = UpcomingEvent,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type UrlResolver<
    R = string,
    Parent = UpcomingEvent,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type VenueResolver<
    R = EventVenue,
    Parent = UpcomingEvent,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type TalksResolver<
    R = Talk[],
    Parent = UpcomingEvent,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
}
/** An event venue */
export namespace EventVenueResolvers {
  export interface Resolvers<TContext = ContextType, TypeParent = EventVenue> {
    city?: CityResolver<string, TypeParent, TContext>

    country?: CountryResolver<string, TypeParent, TContext>

    lat?: LatResolver<number, TypeParent, TContext>

    lon?: LonResolver<number, TypeParent, TContext>

    name?: NameResolver<string, TypeParent, TContext>

    street?: StreetResolver<string, TypeParent, TContext>
  }

  export type CityResolver<
    R = string,
    Parent = EventVenue,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type CountryResolver<
    R = string,
    Parent = EventVenue,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type LatResolver<
    R = number,
    Parent = EventVenue,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type LonResolver<
    R = number,
    Parent = EventVenue,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type NameResolver<
    R = string,
    Parent = EventVenue,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type StreetResolver<
    R = string,
    Parent = EventVenue,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
}
/** A talk */
export namespace TalkResolvers {
  export interface Resolvers<TContext = ContextType, TypeParent = Talk> {
    date?: DateResolver<DateTime, TypeParent, TContext>

    description?: DescriptionResolver<string, TypeParent, TContext>

    isLightningTalk?: IsLightningTalkResolver<boolean, TypeParent, TContext>

    labels?: LabelsResolver<string[], TypeParent, TContext>

    speaker?: SpeakerResolver<Speaker, TypeParent, TContext>

    title?: TitleResolver<string, TypeParent, TContext>
  }

  export type DateResolver<
    R = DateTime,
    Parent = Talk,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type DescriptionResolver<
    R = string,
    Parent = Talk,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type IsLightningTalkResolver<
    R = boolean,
    Parent = Talk,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type LabelsResolver<
    R = string[],
    Parent = Talk,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type SpeakerResolver<
    R = Speaker,
    Parent = Talk,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type TitleResolver<
    R = string,
    Parent = Talk,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
}
/** A speaker */
export namespace SpeakerResolvers {
  export interface Resolvers<TContext = ContextType, TypeParent = Speaker> {
    avatarUrl?: AvatarUrlResolver<string, TypeParent, TContext>

    name?: NameResolver<string, TypeParent, TContext>

    occupation?: OccupationResolver<string, TypeParent, TContext>

    socialName?: SocialNameResolver<Maybe<string>, TypeParent, TContext>

    socialUrl?: SocialUrlResolver<Maybe<string>, TypeParent, TContext>
  }

  export type AvatarUrlResolver<
    R = string,
    Parent = Speaker,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type NameResolver<
    R = string,
    Parent = Speaker,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type OccupationResolver<
    R = string,
    Parent = Speaker,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type SocialNameResolver<
    R = Maybe<string>,
    Parent = Speaker,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
  export type SocialUrlResolver<
    R = Maybe<string>,
    Parent = Speaker,
    TContext = ContextType
  > = Resolver<R, Parent, TContext>
}

/** Directs the executor to skip this field or fragment when the `if` argument is true. */
export type SkipDirectiveResolver<Result> = DirectiveResolverFn<
  Result,
  SkipDirectiveArgs,
  ContextType
>
export interface SkipDirectiveArgs {
  /** Skipped when true. */
  if: boolean
}

/** Directs the executor to include this field or fragment only when the `if` argument is true. */
export type IncludeDirectiveResolver<Result> = DirectiveResolverFn<
  Result,
  IncludeDirectiveArgs,
  ContextType
>
export interface IncludeDirectiveArgs {
  /** Included when true. */
  if: boolean
}

/** Marks an element of a GraphQL schema as no longer supported. */
export type DeprecatedDirectiveResolver<Result> = DirectiveResolverFn<
  Result,
  DeprecatedDirectiveArgs,
  ContextType
>
export interface DeprecatedDirectiveArgs {
  /** Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax (as specified by [CommonMark](https://commonmark.org/). */
  reason?: string
}

export interface DateTimeScalarConfig
  extends GraphQLScalarTypeConfig<DateTime, any> {
  name: 'DateTime'
}

export type IResolvers<TContext = ContextType> = {
  Query?: QueryResolvers.Resolvers<TContext>
  Organizer?: OrganizerResolvers.Resolvers<TContext>
  UpcomingEvent?: UpcomingEventResolvers.Resolvers<TContext>
  EventVenue?: EventVenueResolvers.Resolvers<TContext>
  Talk?: TalkResolvers.Resolvers<TContext>
  Speaker?: SpeakerResolvers.Resolvers<TContext>
  DateTime?: GraphQLScalarType
} & { [typeName: string]: never }

export type IDirectiveResolvers<Result> = {
  skip?: SkipDirectiveResolver<Result>
  include?: IncludeDirectiveResolver<Result>
  deprecated?: DeprecatedDirectiveResolver<Result>
} & { [directiveName: string]: never }
